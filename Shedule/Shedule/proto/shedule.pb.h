// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: shedule.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_shedule_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_shedule_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_shedule_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_shedule_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_shedule_2eproto;
namespace schedule {
class OperationStatus;
struct OperationStatusDefaultTypeInternal;
extern OperationStatusDefaultTypeInternal _OperationStatus_default_instance_;
class ScheduleInfo;
struct ScheduleInfoDefaultTypeInternal;
extern ScheduleInfoDefaultTypeInternal _ScheduleInfo_default_instance_;
class ScheduleInfoContainer;
struct ScheduleInfoContainerDefaultTypeInternal;
extern ScheduleInfoContainerDefaultTypeInternal _ScheduleInfoContainer_default_instance_;
class ScheduleRequest1;
struct ScheduleRequest1DefaultTypeInternal;
extern ScheduleRequest1DefaultTypeInternal _ScheduleRequest1_default_instance_;
class ScheduleRequest2;
struct ScheduleRequest2DefaultTypeInternal;
extern ScheduleRequest2DefaultTypeInternal _ScheduleRequest2_default_instance_;
}  // namespace schedule
PROTOBUF_NAMESPACE_OPEN
template<> ::schedule::OperationStatus* Arena::CreateMaybeMessage<::schedule::OperationStatus>(Arena*);
template<> ::schedule::ScheduleInfo* Arena::CreateMaybeMessage<::schedule::ScheduleInfo>(Arena*);
template<> ::schedule::ScheduleInfoContainer* Arena::CreateMaybeMessage<::schedule::ScheduleInfoContainer>(Arena*);
template<> ::schedule::ScheduleRequest1* Arena::CreateMaybeMessage<::schedule::ScheduleRequest1>(Arena*);
template<> ::schedule::ScheduleRequest2* Arena::CreateMaybeMessage<::schedule::ScheduleRequest2>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace schedule {

// ===================================================================

class ScheduleRequest1 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:schedule.ScheduleRequest1) */ {
 public:
  inline ScheduleRequest1() : ScheduleRequest1(nullptr) {}
  ~ScheduleRequest1() override;
  explicit PROTOBUF_CONSTEXPR ScheduleRequest1(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ScheduleRequest1(const ScheduleRequest1& from);
  ScheduleRequest1(ScheduleRequest1&& from) noexcept
    : ScheduleRequest1() {
    *this = ::std::move(from);
  }

  inline ScheduleRequest1& operator=(const ScheduleRequest1& from) {
    CopyFrom(from);
    return *this;
  }
  inline ScheduleRequest1& operator=(ScheduleRequest1&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ScheduleRequest1& default_instance() {
    return *internal_default_instance();
  }
  static inline const ScheduleRequest1* internal_default_instance() {
    return reinterpret_cast<const ScheduleRequest1*>(
               &_ScheduleRequest1_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ScheduleRequest1& a, ScheduleRequest1& b) {
    a.Swap(&b);
  }
  inline void Swap(ScheduleRequest1* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ScheduleRequest1* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ScheduleRequest1* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ScheduleRequest1>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ScheduleRequest1& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ScheduleRequest1& from) {
    ScheduleRequest1::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ScheduleRequest1* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "schedule.ScheduleRequest1";
  }
  protected:
  explicit ScheduleRequest1(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGroupFieldNumber = 1,
    kDayOfWeekFieldNumber = 2,
  };
  // string group = 1;
  void clear_group();
  const std::string& group() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_group(ArgT0&& arg0, ArgT... args);
  std::string* mutable_group();
  PROTOBUF_NODISCARD std::string* release_group();
  void set_allocated_group(std::string* group);
  private:
  const std::string& _internal_group() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_group(const std::string& value);
  std::string* _internal_mutable_group();
  public:

  // int32 day_of_week = 2;
  void clear_day_of_week();
  int32_t day_of_week() const;
  void set_day_of_week(int32_t value);
  private:
  int32_t _internal_day_of_week() const;
  void _internal_set_day_of_week(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:schedule.ScheduleRequest1)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr group_;
    int32_t day_of_week_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_shedule_2eproto;
};
// -------------------------------------------------------------------

class ScheduleRequest2 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:schedule.ScheduleRequest2) */ {
 public:
  inline ScheduleRequest2() : ScheduleRequest2(nullptr) {}
  ~ScheduleRequest2() override;
  explicit PROTOBUF_CONSTEXPR ScheduleRequest2(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ScheduleRequest2(const ScheduleRequest2& from);
  ScheduleRequest2(ScheduleRequest2&& from) noexcept
    : ScheduleRequest2() {
    *this = ::std::move(from);
  }

  inline ScheduleRequest2& operator=(const ScheduleRequest2& from) {
    CopyFrom(from);
    return *this;
  }
  inline ScheduleRequest2& operator=(ScheduleRequest2&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ScheduleRequest2& default_instance() {
    return *internal_default_instance();
  }
  static inline const ScheduleRequest2* internal_default_instance() {
    return reinterpret_cast<const ScheduleRequest2*>(
               &_ScheduleRequest2_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ScheduleRequest2& a, ScheduleRequest2& b) {
    a.Swap(&b);
  }
  inline void Swap(ScheduleRequest2* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ScheduleRequest2* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ScheduleRequest2* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ScheduleRequest2>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ScheduleRequest2& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ScheduleRequest2& from) {
    ScheduleRequest2::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ScheduleRequest2* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "schedule.ScheduleRequest2";
  }
  protected:
  explicit ScheduleRequest2(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGroupFieldNumber = 1,
  };
  // string group = 1;
  void clear_group();
  const std::string& group() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_group(ArgT0&& arg0, ArgT... args);
  std::string* mutable_group();
  PROTOBUF_NODISCARD std::string* release_group();
  void set_allocated_group(std::string* group);
  private:
  const std::string& _internal_group() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_group(const std::string& value);
  std::string* _internal_mutable_group();
  public:

  // @@protoc_insertion_point(class_scope:schedule.ScheduleRequest2)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr group_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_shedule_2eproto;
};
// -------------------------------------------------------------------

class OperationStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:schedule.OperationStatus) */ {
 public:
  inline OperationStatus() : OperationStatus(nullptr) {}
  ~OperationStatus() override;
  explicit PROTOBUF_CONSTEXPR OperationStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OperationStatus(const OperationStatus& from);
  OperationStatus(OperationStatus&& from) noexcept
    : OperationStatus() {
    *this = ::std::move(from);
  }

  inline OperationStatus& operator=(const OperationStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline OperationStatus& operator=(OperationStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OperationStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const OperationStatus* internal_default_instance() {
    return reinterpret_cast<const OperationStatus*>(
               &_OperationStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(OperationStatus& a, OperationStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(OperationStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OperationStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OperationStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OperationStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OperationStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OperationStatus& from) {
    OperationStatus::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OperationStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "schedule.OperationStatus";
  }
  protected:
  explicit OperationStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorFieldNumber = 2,
    kErrorFlagFieldNumber = 1,
  };
  // string error = 2;
  void clear_error();
  const std::string& error() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error();
  PROTOBUF_NODISCARD std::string* release_error();
  void set_allocated_error(std::string* error);
  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(const std::string& value);
  std::string* _internal_mutable_error();
  public:

  // bool error_flag = 1;
  void clear_error_flag();
  bool error_flag() const;
  void set_error_flag(bool value);
  private:
  bool _internal_error_flag() const;
  void _internal_set_error_flag(bool value);
  public:

  // @@protoc_insertion_point(class_scope:schedule.OperationStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
    bool error_flag_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_shedule_2eproto;
};
// -------------------------------------------------------------------

class ScheduleInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:schedule.ScheduleInfo) */ {
 public:
  inline ScheduleInfo() : ScheduleInfo(nullptr) {}
  ~ScheduleInfo() override;
  explicit PROTOBUF_CONSTEXPR ScheduleInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ScheduleInfo(const ScheduleInfo& from);
  ScheduleInfo(ScheduleInfo&& from) noexcept
    : ScheduleInfo() {
    *this = ::std::move(from);
  }

  inline ScheduleInfo& operator=(const ScheduleInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ScheduleInfo& operator=(ScheduleInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ScheduleInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ScheduleInfo* internal_default_instance() {
    return reinterpret_cast<const ScheduleInfo*>(
               &_ScheduleInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ScheduleInfo& a, ScheduleInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ScheduleInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ScheduleInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ScheduleInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ScheduleInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ScheduleInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ScheduleInfo& from) {
    ScheduleInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ScheduleInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "schedule.ScheduleInfo";
  }
  protected:
  explicit ScheduleInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGroupFieldNumber = 1,
    kAuditFieldNumber = 2,
    kStartTimeFieldNumber = 3,
    kEndTimeFieldNumber = 4,
    kLessonNameFieldNumber = 5,
    kParityFieldNumber = 6,
    kDayOfWeekFieldNumber = 7,
    kLessonCountFieldNumber = 8,
  };
  // string group = 1;
  void clear_group();
  const std::string& group() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_group(ArgT0&& arg0, ArgT... args);
  std::string* mutable_group();
  PROTOBUF_NODISCARD std::string* release_group();
  void set_allocated_group(std::string* group);
  private:
  const std::string& _internal_group() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_group(const std::string& value);
  std::string* _internal_mutable_group();
  public:

  // string audit = 2;
  void clear_audit();
  const std::string& audit() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_audit(ArgT0&& arg0, ArgT... args);
  std::string* mutable_audit();
  PROTOBUF_NODISCARD std::string* release_audit();
  void set_allocated_audit(std::string* audit);
  private:
  const std::string& _internal_audit() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_audit(const std::string& value);
  std::string* _internal_mutable_audit();
  public:

  // string start_time = 3;
  void clear_start_time();
  const std::string& start_time() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_start_time(ArgT0&& arg0, ArgT... args);
  std::string* mutable_start_time();
  PROTOBUF_NODISCARD std::string* release_start_time();
  void set_allocated_start_time(std::string* start_time);
  private:
  const std::string& _internal_start_time() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_start_time(const std::string& value);
  std::string* _internal_mutable_start_time();
  public:

  // string end_time = 4;
  void clear_end_time();
  const std::string& end_time() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_end_time(ArgT0&& arg0, ArgT... args);
  std::string* mutable_end_time();
  PROTOBUF_NODISCARD std::string* release_end_time();
  void set_allocated_end_time(std::string* end_time);
  private:
  const std::string& _internal_end_time() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_end_time(const std::string& value);
  std::string* _internal_mutable_end_time();
  public:

  // string lesson_name = 5;
  void clear_lesson_name();
  const std::string& lesson_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_lesson_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_lesson_name();
  PROTOBUF_NODISCARD std::string* release_lesson_name();
  void set_allocated_lesson_name(std::string* lesson_name);
  private:
  const std::string& _internal_lesson_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_lesson_name(const std::string& value);
  std::string* _internal_mutable_lesson_name();
  public:

  // bool parity = 6;
  void clear_parity();
  bool parity() const;
  void set_parity(bool value);
  private:
  bool _internal_parity() const;
  void _internal_set_parity(bool value);
  public:

  // int32 day_of_week = 7;
  void clear_day_of_week();
  int32_t day_of_week() const;
  void set_day_of_week(int32_t value);
  private:
  int32_t _internal_day_of_week() const;
  void _internal_set_day_of_week(int32_t value);
  public:

  // int32 lesson_count = 8;
  void clear_lesson_count();
  int32_t lesson_count() const;
  void set_lesson_count(int32_t value);
  private:
  int32_t _internal_lesson_count() const;
  void _internal_set_lesson_count(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:schedule.ScheduleInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr group_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr audit_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr start_time_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr end_time_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr lesson_name_;
    bool parity_;
    int32_t day_of_week_;
    int32_t lesson_count_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_shedule_2eproto;
};
// -------------------------------------------------------------------

class ScheduleInfoContainer final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:schedule.ScheduleInfoContainer) */ {
 public:
  inline ScheduleInfoContainer() : ScheduleInfoContainer(nullptr) {}
  ~ScheduleInfoContainer() override;
  explicit PROTOBUF_CONSTEXPR ScheduleInfoContainer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ScheduleInfoContainer(const ScheduleInfoContainer& from);
  ScheduleInfoContainer(ScheduleInfoContainer&& from) noexcept
    : ScheduleInfoContainer() {
    *this = ::std::move(from);
  }

  inline ScheduleInfoContainer& operator=(const ScheduleInfoContainer& from) {
    CopyFrom(from);
    return *this;
  }
  inline ScheduleInfoContainer& operator=(ScheduleInfoContainer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ScheduleInfoContainer& default_instance() {
    return *internal_default_instance();
  }
  static inline const ScheduleInfoContainer* internal_default_instance() {
    return reinterpret_cast<const ScheduleInfoContainer*>(
               &_ScheduleInfoContainer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ScheduleInfoContainer& a, ScheduleInfoContainer& b) {
    a.Swap(&b);
  }
  inline void Swap(ScheduleInfoContainer* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ScheduleInfoContainer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ScheduleInfoContainer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ScheduleInfoContainer>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ScheduleInfoContainer& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ScheduleInfoContainer& from) {
    ScheduleInfoContainer::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ScheduleInfoContainer* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "schedule.ScheduleInfoContainer";
  }
  protected:
  explicit ScheduleInfoContainer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kScheduleContainerFieldNumber = 1,
  };
  // repeated .schedule.ScheduleInfo schedule_container = 1;
  int schedule_container_size() const;
  private:
  int _internal_schedule_container_size() const;
  public:
  void clear_schedule_container();
  ::schedule::ScheduleInfo* mutable_schedule_container(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::schedule::ScheduleInfo >*
      mutable_schedule_container();
  private:
  const ::schedule::ScheduleInfo& _internal_schedule_container(int index) const;
  ::schedule::ScheduleInfo* _internal_add_schedule_container();
  public:
  const ::schedule::ScheduleInfo& schedule_container(int index) const;
  ::schedule::ScheduleInfo* add_schedule_container();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::schedule::ScheduleInfo >&
      schedule_container() const;

  // @@protoc_insertion_point(class_scope:schedule.ScheduleInfoContainer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::schedule::ScheduleInfo > schedule_container_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_shedule_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ScheduleRequest1

// string group = 1;
inline void ScheduleRequest1::clear_group() {
  _impl_.group_.ClearToEmpty();
}
inline const std::string& ScheduleRequest1::group() const {
  // @@protoc_insertion_point(field_get:schedule.ScheduleRequest1.group)
  return _internal_group();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ScheduleRequest1::set_group(ArgT0&& arg0, ArgT... args) {
 
 _impl_.group_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:schedule.ScheduleRequest1.group)
}
inline std::string* ScheduleRequest1::mutable_group() {
  std::string* _s = _internal_mutable_group();
  // @@protoc_insertion_point(field_mutable:schedule.ScheduleRequest1.group)
  return _s;
}
inline const std::string& ScheduleRequest1::_internal_group() const {
  return _impl_.group_.Get();
}
inline void ScheduleRequest1::_internal_set_group(const std::string& value) {
  
  _impl_.group_.Set(value, GetArenaForAllocation());
}
inline std::string* ScheduleRequest1::_internal_mutable_group() {
  
  return _impl_.group_.Mutable(GetArenaForAllocation());
}
inline std::string* ScheduleRequest1::release_group() {
  // @@protoc_insertion_point(field_release:schedule.ScheduleRequest1.group)
  return _impl_.group_.Release();
}
inline void ScheduleRequest1::set_allocated_group(std::string* group) {
  if (group != nullptr) {
    
  } else {
    
  }
  _impl_.group_.SetAllocated(group, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.group_.IsDefault()) {
    _impl_.group_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:schedule.ScheduleRequest1.group)
}

// int32 day_of_week = 2;
inline void ScheduleRequest1::clear_day_of_week() {
  _impl_.day_of_week_ = 0;
}
inline int32_t ScheduleRequest1::_internal_day_of_week() const {
  return _impl_.day_of_week_;
}
inline int32_t ScheduleRequest1::day_of_week() const {
  // @@protoc_insertion_point(field_get:schedule.ScheduleRequest1.day_of_week)
  return _internal_day_of_week();
}
inline void ScheduleRequest1::_internal_set_day_of_week(int32_t value) {
  
  _impl_.day_of_week_ = value;
}
inline void ScheduleRequest1::set_day_of_week(int32_t value) {
  _internal_set_day_of_week(value);
  // @@protoc_insertion_point(field_set:schedule.ScheduleRequest1.day_of_week)
}

// -------------------------------------------------------------------

// ScheduleRequest2

// string group = 1;
inline void ScheduleRequest2::clear_group() {
  _impl_.group_.ClearToEmpty();
}
inline const std::string& ScheduleRequest2::group() const {
  // @@protoc_insertion_point(field_get:schedule.ScheduleRequest2.group)
  return _internal_group();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ScheduleRequest2::set_group(ArgT0&& arg0, ArgT... args) {
 
 _impl_.group_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:schedule.ScheduleRequest2.group)
}
inline std::string* ScheduleRequest2::mutable_group() {
  std::string* _s = _internal_mutable_group();
  // @@protoc_insertion_point(field_mutable:schedule.ScheduleRequest2.group)
  return _s;
}
inline const std::string& ScheduleRequest2::_internal_group() const {
  return _impl_.group_.Get();
}
inline void ScheduleRequest2::_internal_set_group(const std::string& value) {
  
  _impl_.group_.Set(value, GetArenaForAllocation());
}
inline std::string* ScheduleRequest2::_internal_mutable_group() {
  
  return _impl_.group_.Mutable(GetArenaForAllocation());
}
inline std::string* ScheduleRequest2::release_group() {
  // @@protoc_insertion_point(field_release:schedule.ScheduleRequest2.group)
  return _impl_.group_.Release();
}
inline void ScheduleRequest2::set_allocated_group(std::string* group) {
  if (group != nullptr) {
    
  } else {
    
  }
  _impl_.group_.SetAllocated(group, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.group_.IsDefault()) {
    _impl_.group_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:schedule.ScheduleRequest2.group)
}

// -------------------------------------------------------------------

// OperationStatus

// bool error_flag = 1;
inline void OperationStatus::clear_error_flag() {
  _impl_.error_flag_ = false;
}
inline bool OperationStatus::_internal_error_flag() const {
  return _impl_.error_flag_;
}
inline bool OperationStatus::error_flag() const {
  // @@protoc_insertion_point(field_get:schedule.OperationStatus.error_flag)
  return _internal_error_flag();
}
inline void OperationStatus::_internal_set_error_flag(bool value) {
  
  _impl_.error_flag_ = value;
}
inline void OperationStatus::set_error_flag(bool value) {
  _internal_set_error_flag(value);
  // @@protoc_insertion_point(field_set:schedule.OperationStatus.error_flag)
}

// string error = 2;
inline void OperationStatus::clear_error() {
  _impl_.error_.ClearToEmpty();
}
inline const std::string& OperationStatus::error() const {
  // @@protoc_insertion_point(field_get:schedule.OperationStatus.error)
  return _internal_error();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OperationStatus::set_error(ArgT0&& arg0, ArgT... args) {
 
 _impl_.error_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:schedule.OperationStatus.error)
}
inline std::string* OperationStatus::mutable_error() {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:schedule.OperationStatus.error)
  return _s;
}
inline const std::string& OperationStatus::_internal_error() const {
  return _impl_.error_.Get();
}
inline void OperationStatus::_internal_set_error(const std::string& value) {
  
  _impl_.error_.Set(value, GetArenaForAllocation());
}
inline std::string* OperationStatus::_internal_mutable_error() {
  
  return _impl_.error_.Mutable(GetArenaForAllocation());
}
inline std::string* OperationStatus::release_error() {
  // @@protoc_insertion_point(field_release:schedule.OperationStatus.error)
  return _impl_.error_.Release();
}
inline void OperationStatus::set_allocated_error(std::string* error) {
  if (error != nullptr) {
    
  } else {
    
  }
  _impl_.error_.SetAllocated(error, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_.IsDefault()) {
    _impl_.error_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:schedule.OperationStatus.error)
}

// -------------------------------------------------------------------

// ScheduleInfo

// string group = 1;
inline void ScheduleInfo::clear_group() {
  _impl_.group_.ClearToEmpty();
}
inline const std::string& ScheduleInfo::group() const {
  // @@protoc_insertion_point(field_get:schedule.ScheduleInfo.group)
  return _internal_group();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ScheduleInfo::set_group(ArgT0&& arg0, ArgT... args) {
 
 _impl_.group_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:schedule.ScheduleInfo.group)
}
inline std::string* ScheduleInfo::mutable_group() {
  std::string* _s = _internal_mutable_group();
  // @@protoc_insertion_point(field_mutable:schedule.ScheduleInfo.group)
  return _s;
}
inline const std::string& ScheduleInfo::_internal_group() const {
  return _impl_.group_.Get();
}
inline void ScheduleInfo::_internal_set_group(const std::string& value) {
  
  _impl_.group_.Set(value, GetArenaForAllocation());
}
inline std::string* ScheduleInfo::_internal_mutable_group() {
  
  return _impl_.group_.Mutable(GetArenaForAllocation());
}
inline std::string* ScheduleInfo::release_group() {
  // @@protoc_insertion_point(field_release:schedule.ScheduleInfo.group)
  return _impl_.group_.Release();
}
inline void ScheduleInfo::set_allocated_group(std::string* group) {
  if (group != nullptr) {
    
  } else {
    
  }
  _impl_.group_.SetAllocated(group, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.group_.IsDefault()) {
    _impl_.group_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:schedule.ScheduleInfo.group)
}

// string audit = 2;
inline void ScheduleInfo::clear_audit() {
  _impl_.audit_.ClearToEmpty();
}
inline const std::string& ScheduleInfo::audit() const {
  // @@protoc_insertion_point(field_get:schedule.ScheduleInfo.audit)
  return _internal_audit();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ScheduleInfo::set_audit(ArgT0&& arg0, ArgT... args) {
 
 _impl_.audit_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:schedule.ScheduleInfo.audit)
}
inline std::string* ScheduleInfo::mutable_audit() {
  std::string* _s = _internal_mutable_audit();
  // @@protoc_insertion_point(field_mutable:schedule.ScheduleInfo.audit)
  return _s;
}
inline const std::string& ScheduleInfo::_internal_audit() const {
  return _impl_.audit_.Get();
}
inline void ScheduleInfo::_internal_set_audit(const std::string& value) {
  
  _impl_.audit_.Set(value, GetArenaForAllocation());
}
inline std::string* ScheduleInfo::_internal_mutable_audit() {
  
  return _impl_.audit_.Mutable(GetArenaForAllocation());
}
inline std::string* ScheduleInfo::release_audit() {
  // @@protoc_insertion_point(field_release:schedule.ScheduleInfo.audit)
  return _impl_.audit_.Release();
}
inline void ScheduleInfo::set_allocated_audit(std::string* audit) {
  if (audit != nullptr) {
    
  } else {
    
  }
  _impl_.audit_.SetAllocated(audit, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.audit_.IsDefault()) {
    _impl_.audit_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:schedule.ScheduleInfo.audit)
}

// string start_time = 3;
inline void ScheduleInfo::clear_start_time() {
  _impl_.start_time_.ClearToEmpty();
}
inline const std::string& ScheduleInfo::start_time() const {
  // @@protoc_insertion_point(field_get:schedule.ScheduleInfo.start_time)
  return _internal_start_time();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ScheduleInfo::set_start_time(ArgT0&& arg0, ArgT... args) {
 
 _impl_.start_time_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:schedule.ScheduleInfo.start_time)
}
inline std::string* ScheduleInfo::mutable_start_time() {
  std::string* _s = _internal_mutable_start_time();
  // @@protoc_insertion_point(field_mutable:schedule.ScheduleInfo.start_time)
  return _s;
}
inline const std::string& ScheduleInfo::_internal_start_time() const {
  return _impl_.start_time_.Get();
}
inline void ScheduleInfo::_internal_set_start_time(const std::string& value) {
  
  _impl_.start_time_.Set(value, GetArenaForAllocation());
}
inline std::string* ScheduleInfo::_internal_mutable_start_time() {
  
  return _impl_.start_time_.Mutable(GetArenaForAllocation());
}
inline std::string* ScheduleInfo::release_start_time() {
  // @@protoc_insertion_point(field_release:schedule.ScheduleInfo.start_time)
  return _impl_.start_time_.Release();
}
inline void ScheduleInfo::set_allocated_start_time(std::string* start_time) {
  if (start_time != nullptr) {
    
  } else {
    
  }
  _impl_.start_time_.SetAllocated(start_time, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.start_time_.IsDefault()) {
    _impl_.start_time_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:schedule.ScheduleInfo.start_time)
}

// string end_time = 4;
inline void ScheduleInfo::clear_end_time() {
  _impl_.end_time_.ClearToEmpty();
}
inline const std::string& ScheduleInfo::end_time() const {
  // @@protoc_insertion_point(field_get:schedule.ScheduleInfo.end_time)
  return _internal_end_time();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ScheduleInfo::set_end_time(ArgT0&& arg0, ArgT... args) {
 
 _impl_.end_time_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:schedule.ScheduleInfo.end_time)
}
inline std::string* ScheduleInfo::mutable_end_time() {
  std::string* _s = _internal_mutable_end_time();
  // @@protoc_insertion_point(field_mutable:schedule.ScheduleInfo.end_time)
  return _s;
}
inline const std::string& ScheduleInfo::_internal_end_time() const {
  return _impl_.end_time_.Get();
}
inline void ScheduleInfo::_internal_set_end_time(const std::string& value) {
  
  _impl_.end_time_.Set(value, GetArenaForAllocation());
}
inline std::string* ScheduleInfo::_internal_mutable_end_time() {
  
  return _impl_.end_time_.Mutable(GetArenaForAllocation());
}
inline std::string* ScheduleInfo::release_end_time() {
  // @@protoc_insertion_point(field_release:schedule.ScheduleInfo.end_time)
  return _impl_.end_time_.Release();
}
inline void ScheduleInfo::set_allocated_end_time(std::string* end_time) {
  if (end_time != nullptr) {
    
  } else {
    
  }
  _impl_.end_time_.SetAllocated(end_time, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.end_time_.IsDefault()) {
    _impl_.end_time_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:schedule.ScheduleInfo.end_time)
}

// string lesson_name = 5;
inline void ScheduleInfo::clear_lesson_name() {
  _impl_.lesson_name_.ClearToEmpty();
}
inline const std::string& ScheduleInfo::lesson_name() const {
  // @@protoc_insertion_point(field_get:schedule.ScheduleInfo.lesson_name)
  return _internal_lesson_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ScheduleInfo::set_lesson_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.lesson_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:schedule.ScheduleInfo.lesson_name)
}
inline std::string* ScheduleInfo::mutable_lesson_name() {
  std::string* _s = _internal_mutable_lesson_name();
  // @@protoc_insertion_point(field_mutable:schedule.ScheduleInfo.lesson_name)
  return _s;
}
inline const std::string& ScheduleInfo::_internal_lesson_name() const {
  return _impl_.lesson_name_.Get();
}
inline void ScheduleInfo::_internal_set_lesson_name(const std::string& value) {
  
  _impl_.lesson_name_.Set(value, GetArenaForAllocation());
}
inline std::string* ScheduleInfo::_internal_mutable_lesson_name() {
  
  return _impl_.lesson_name_.Mutable(GetArenaForAllocation());
}
inline std::string* ScheduleInfo::release_lesson_name() {
  // @@protoc_insertion_point(field_release:schedule.ScheduleInfo.lesson_name)
  return _impl_.lesson_name_.Release();
}
inline void ScheduleInfo::set_allocated_lesson_name(std::string* lesson_name) {
  if (lesson_name != nullptr) {
    
  } else {
    
  }
  _impl_.lesson_name_.SetAllocated(lesson_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.lesson_name_.IsDefault()) {
    _impl_.lesson_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:schedule.ScheduleInfo.lesson_name)
}

// bool parity = 6;
inline void ScheduleInfo::clear_parity() {
  _impl_.parity_ = false;
}
inline bool ScheduleInfo::_internal_parity() const {
  return _impl_.parity_;
}
inline bool ScheduleInfo::parity() const {
  // @@protoc_insertion_point(field_get:schedule.ScheduleInfo.parity)
  return _internal_parity();
}
inline void ScheduleInfo::_internal_set_parity(bool value) {
  
  _impl_.parity_ = value;
}
inline void ScheduleInfo::set_parity(bool value) {
  _internal_set_parity(value);
  // @@protoc_insertion_point(field_set:schedule.ScheduleInfo.parity)
}

// int32 day_of_week = 7;
inline void ScheduleInfo::clear_day_of_week() {
  _impl_.day_of_week_ = 0;
}
inline int32_t ScheduleInfo::_internal_day_of_week() const {
  return _impl_.day_of_week_;
}
inline int32_t ScheduleInfo::day_of_week() const {
  // @@protoc_insertion_point(field_get:schedule.ScheduleInfo.day_of_week)
  return _internal_day_of_week();
}
inline void ScheduleInfo::_internal_set_day_of_week(int32_t value) {
  
  _impl_.day_of_week_ = value;
}
inline void ScheduleInfo::set_day_of_week(int32_t value) {
  _internal_set_day_of_week(value);
  // @@protoc_insertion_point(field_set:schedule.ScheduleInfo.day_of_week)
}

// int32 lesson_count = 8;
inline void ScheduleInfo::clear_lesson_count() {
  _impl_.lesson_count_ = 0;
}
inline int32_t ScheduleInfo::_internal_lesson_count() const {
  return _impl_.lesson_count_;
}
inline int32_t ScheduleInfo::lesson_count() const {
  // @@protoc_insertion_point(field_get:schedule.ScheduleInfo.lesson_count)
  return _internal_lesson_count();
}
inline void ScheduleInfo::_internal_set_lesson_count(int32_t value) {
  
  _impl_.lesson_count_ = value;
}
inline void ScheduleInfo::set_lesson_count(int32_t value) {
  _internal_set_lesson_count(value);
  // @@protoc_insertion_point(field_set:schedule.ScheduleInfo.lesson_count)
}

// -------------------------------------------------------------------

// ScheduleInfoContainer

// repeated .schedule.ScheduleInfo schedule_container = 1;
inline int ScheduleInfoContainer::_internal_schedule_container_size() const {
  return _impl_.schedule_container_.size();
}
inline int ScheduleInfoContainer::schedule_container_size() const {
  return _internal_schedule_container_size();
}
inline void ScheduleInfoContainer::clear_schedule_container() {
  _impl_.schedule_container_.Clear();
}
inline ::schedule::ScheduleInfo* ScheduleInfoContainer::mutable_schedule_container(int index) {
  // @@protoc_insertion_point(field_mutable:schedule.ScheduleInfoContainer.schedule_container)
  return _impl_.schedule_container_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::schedule::ScheduleInfo >*
ScheduleInfoContainer::mutable_schedule_container() {
  // @@protoc_insertion_point(field_mutable_list:schedule.ScheduleInfoContainer.schedule_container)
  return &_impl_.schedule_container_;
}
inline const ::schedule::ScheduleInfo& ScheduleInfoContainer::_internal_schedule_container(int index) const {
  return _impl_.schedule_container_.Get(index);
}
inline const ::schedule::ScheduleInfo& ScheduleInfoContainer::schedule_container(int index) const {
  // @@protoc_insertion_point(field_get:schedule.ScheduleInfoContainer.schedule_container)
  return _internal_schedule_container(index);
}
inline ::schedule::ScheduleInfo* ScheduleInfoContainer::_internal_add_schedule_container() {
  return _impl_.schedule_container_.Add();
}
inline ::schedule::ScheduleInfo* ScheduleInfoContainer::add_schedule_container() {
  ::schedule::ScheduleInfo* _add = _internal_add_schedule_container();
  // @@protoc_insertion_point(field_add:schedule.ScheduleInfoContainer.schedule_container)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::schedule::ScheduleInfo >&
ScheduleInfoContainer::schedule_container() const {
  // @@protoc_insertion_point(field_list:schedule.ScheduleInfoContainer.schedule_container)
  return _impl_.schedule_container_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace schedule

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_shedule_2eproto
