// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: schedule.proto

#include "schedule.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace schedule {
PROTOBUF_CONSTEXPR ScheduleRequest::ScheduleRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.group_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ScheduleRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ScheduleRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ScheduleRequestDefaultTypeInternal() {}
  union {
    ScheduleRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ScheduleRequestDefaultTypeInternal _ScheduleRequest_default_instance_;
PROTOBUF_CONSTEXPR ScheduleResponse::ScheduleResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.oddweek_)*/{}
  , /*decltype(_impl_.evenweek_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ScheduleResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ScheduleResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ScheduleResponseDefaultTypeInternal() {}
  union {
    ScheduleResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ScheduleResponseDefaultTypeInternal _ScheduleResponse_default_instance_;
PROTOBUF_CONSTEXPR Day::Day(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.subjects_)*/{}
  , /*decltype(_impl_.weekday_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct DayDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DayDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DayDefaultTypeInternal() {}
  union {
    Day _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DayDefaultTypeInternal _Day_default_instance_;
PROTOBUF_CONSTEXPR Subject::Subject(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.room_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.lecturer_)*/nullptr
  , /*decltype(_impl_.timerange_)*/nullptr
  , /*decltype(_impl_.type_)*/0
  , /*decltype(_impl_.number_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SubjectDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SubjectDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SubjectDefaultTypeInternal() {}
  union {
    Subject _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SubjectDefaultTypeInternal _Subject_default_instance_;
PROTOBUF_CONSTEXPR Lecturer::Lecturer(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.firstname_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.lastname_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.middlename_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct LecturerDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LecturerDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LecturerDefaultTypeInternal() {}
  union {
    Lecturer _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LecturerDefaultTypeInternal _Lecturer_default_instance_;
PROTOBUF_CONSTEXPR TimeRange::TimeRange(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.start_)*/nullptr
  , /*decltype(_impl_.end_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TimeRangeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TimeRangeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TimeRangeDefaultTypeInternal() {}
  union {
    TimeRange _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TimeRangeDefaultTypeInternal _TimeRange_default_instance_;
PROTOBUF_CONSTEXPR TimeOfDay::TimeOfDay(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.hour_)*/0
  , /*decltype(_impl_.minute_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TimeOfDayDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TimeOfDayDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TimeOfDayDefaultTypeInternal() {}
  union {
    TimeOfDay _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TimeOfDayDefaultTypeInternal _TimeOfDay_default_instance_;
}  // namespace schedule
static ::_pb::Metadata file_level_metadata_schedule_2eproto[7];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_schedule_2eproto[1];
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_schedule_2eproto = nullptr;

const uint32_t TableStruct_schedule_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::schedule::ScheduleRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::schedule::ScheduleRequest, _impl_.group_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::schedule::ScheduleResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::schedule::ScheduleResponse, _impl_.oddweek_),
  PROTOBUF_FIELD_OFFSET(::schedule::ScheduleResponse, _impl_.evenweek_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::schedule::Day, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::schedule::Day, _impl_.weekday_),
  PROTOBUF_FIELD_OFFSET(::schedule::Day, _impl_.subjects_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::schedule::Subject, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::schedule::Subject, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::schedule::Subject, _impl_.room_),
  PROTOBUF_FIELD_OFFSET(::schedule::Subject, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::schedule::Subject, _impl_.lecturer_),
  PROTOBUF_FIELD_OFFSET(::schedule::Subject, _impl_.number_),
  PROTOBUF_FIELD_OFFSET(::schedule::Subject, _impl_.timerange_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::schedule::Lecturer, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::schedule::Lecturer, _impl_.firstname_),
  PROTOBUF_FIELD_OFFSET(::schedule::Lecturer, _impl_.lastname_),
  PROTOBUF_FIELD_OFFSET(::schedule::Lecturer, _impl_.middlename_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::schedule::TimeRange, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::schedule::TimeRange, _impl_.start_),
  PROTOBUF_FIELD_OFFSET(::schedule::TimeRange, _impl_.end_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::schedule::TimeOfDay, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::schedule::TimeOfDay, _impl_.hour_),
  PROTOBUF_FIELD_OFFSET(::schedule::TimeOfDay, _impl_.minute_),
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, -1, sizeof(::schedule::ScheduleRequest)},
  { 7, -1, -1, sizeof(::schedule::ScheduleResponse)},
  { 15, -1, -1, sizeof(::schedule::Day)},
  { 23, -1, -1, sizeof(::schedule::Subject)},
  { 35, -1, -1, sizeof(::schedule::Lecturer)},
  { 44, -1, -1, sizeof(::schedule::TimeRange)},
  { 52, -1, -1, sizeof(::schedule::TimeOfDay)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::schedule::_ScheduleRequest_default_instance_._instance,
  &::schedule::_ScheduleResponse_default_instance_._instance,
  &::schedule::_Day_default_instance_._instance,
  &::schedule::_Subject_default_instance_._instance,
  &::schedule::_Lecturer_default_instance_._instance,
  &::schedule::_TimeRange_default_instance_._instance,
  &::schedule::_TimeOfDay_default_instance_._instance,
};

const char descriptor_table_protodef_schedule_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\016schedule.proto\022\010schedule\" \n\017ScheduleRe"
  "quest\022\r\n\005group\030\001 \001(\t\"S\n\020ScheduleResponse"
  "\022\036\n\007oddWeek\030\001 \003(\0132\r.schedule.Day\022\037\n\010even"
  "Week\030\002 \003(\0132\r.schedule.Day\";\n\003Day\022\017\n\007week"
  "day\030\001 \001(\005\022#\n\010subjects\030\002 \003(\0132\021.schedule.S"
  "ubject\"\343\001\n\007Subject\022\014\n\004name\030\001 \001(\t\022\014\n\004room"
  "\030\002 \001(\t\022+\n\004type\030\003 \001(\0162\035.schedule.Subject."
  "SubjectType\022$\n\010lecturer\030\004 \001(\0132\022.schedule"
  ".Lecturer\022\016\n\006number\030\005 \001(\005\022&\n\ttimeRange\030\006"
  " \001(\0132\023.schedule.TimeRange\"1\n\013SubjectType"
  "\022\013\n\007LECTURE\020\000\022\014\n\010PRACTICE\020\001\022\007\n\003LAB\020\002\"C\n\010"
  "Lecturer\022\021\n\tfirstName\030\001 \001(\t\022\020\n\010lastName\030"
  "\002 \001(\t\022\022\n\nmiddleName\030\003 \001(\t\"Q\n\tTimeRange\022\""
  "\n\005start\030\001 \001(\0132\023.schedule.TimeOfDay\022 \n\003en"
  "d\030\002 \001(\0132\023.schedule.TimeOfDay\")\n\tTimeOfDa"
  "y\022\014\n\004hour\030\001 \001(\005\022\016\n\006minute\030\002 \001(\0052X\n\016Shedu"
  "leService\022F\n\013GetSchedule\022\031.schedule.Sche"
  "duleRequest\032\032.schedule.ScheduleResponse\""
  "\000b\006proto3"
  ;
static ::_pbi::once_flag descriptor_table_schedule_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_schedule_2eproto = {
    false, false, 729, descriptor_table_protodef_schedule_2eproto,
    "schedule.proto",
    &descriptor_table_schedule_2eproto_once, nullptr, 0, 7,
    schemas, file_default_instances, TableStruct_schedule_2eproto::offsets,
    file_level_metadata_schedule_2eproto, file_level_enum_descriptors_schedule_2eproto,
    file_level_service_descriptors_schedule_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_schedule_2eproto_getter() {
  return &descriptor_table_schedule_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_schedule_2eproto(&descriptor_table_schedule_2eproto);
namespace schedule {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Subject_SubjectType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_schedule_2eproto);
  return file_level_enum_descriptors_schedule_2eproto[0];
}
bool Subject_SubjectType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr Subject_SubjectType Subject::LECTURE;
constexpr Subject_SubjectType Subject::PRACTICE;
constexpr Subject_SubjectType Subject::LAB;
constexpr Subject_SubjectType Subject::SubjectType_MIN;
constexpr Subject_SubjectType Subject::SubjectType_MAX;
constexpr int Subject::SubjectType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

// ===================================================================

class ScheduleRequest::_Internal {
 public:
};

ScheduleRequest::ScheduleRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:schedule.ScheduleRequest)
}
ScheduleRequest::ScheduleRequest(const ScheduleRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ScheduleRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.group_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.group_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.group_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_group().empty()) {
    _this->_impl_.group_.Set(from._internal_group(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:schedule.ScheduleRequest)
}

inline void ScheduleRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.group_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.group_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.group_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ScheduleRequest::~ScheduleRequest() {
  // @@protoc_insertion_point(destructor:schedule.ScheduleRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ScheduleRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.group_.Destroy();
}

void ScheduleRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ScheduleRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:schedule.ScheduleRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.group_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ScheduleRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string group = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_group();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "schedule.ScheduleRequest.group"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ScheduleRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:schedule.ScheduleRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string group = 1;
  if (!this->_internal_group().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_group().data(), static_cast<int>(this->_internal_group().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "schedule.ScheduleRequest.group");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_group(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:schedule.ScheduleRequest)
  return target;
}

size_t ScheduleRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:schedule.ScheduleRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string group = 1;
  if (!this->_internal_group().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_group());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ScheduleRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ScheduleRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ScheduleRequest::GetClassData() const { return &_class_data_; }


void ScheduleRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ScheduleRequest*>(&to_msg);
  auto& from = static_cast<const ScheduleRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:schedule.ScheduleRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_group().empty()) {
    _this->_internal_set_group(from._internal_group());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ScheduleRequest::CopyFrom(const ScheduleRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:schedule.ScheduleRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ScheduleRequest::IsInitialized() const {
  return true;
}

void ScheduleRequest::InternalSwap(ScheduleRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.group_, lhs_arena,
      &other->_impl_.group_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata ScheduleRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_schedule_2eproto_getter, &descriptor_table_schedule_2eproto_once,
      file_level_metadata_schedule_2eproto[0]);
}

// ===================================================================

class ScheduleResponse::_Internal {
 public:
};

ScheduleResponse::ScheduleResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:schedule.ScheduleResponse)
}
ScheduleResponse::ScheduleResponse(const ScheduleResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ScheduleResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.oddweek_){from._impl_.oddweek_}
    , decltype(_impl_.evenweek_){from._impl_.evenweek_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:schedule.ScheduleResponse)
}

inline void ScheduleResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.oddweek_){arena}
    , decltype(_impl_.evenweek_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ScheduleResponse::~ScheduleResponse() {
  // @@protoc_insertion_point(destructor:schedule.ScheduleResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ScheduleResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.oddweek_.~RepeatedPtrField();
  _impl_.evenweek_.~RepeatedPtrField();
}

void ScheduleResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ScheduleResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:schedule.ScheduleResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.oddweek_.Clear();
  _impl_.evenweek_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ScheduleResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .schedule.Day oddWeek = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_oddweek(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .schedule.Day evenWeek = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_evenweek(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ScheduleResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:schedule.ScheduleResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .schedule.Day oddWeek = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_oddweek_size()); i < n; i++) {
    const auto& repfield = this->_internal_oddweek(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .schedule.Day evenWeek = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_evenweek_size()); i < n; i++) {
    const auto& repfield = this->_internal_evenweek(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:schedule.ScheduleResponse)
  return target;
}

size_t ScheduleResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:schedule.ScheduleResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .schedule.Day oddWeek = 1;
  total_size += 1UL * this->_internal_oddweek_size();
  for (const auto& msg : this->_impl_.oddweek_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .schedule.Day evenWeek = 2;
  total_size += 1UL * this->_internal_evenweek_size();
  for (const auto& msg : this->_impl_.evenweek_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ScheduleResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ScheduleResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ScheduleResponse::GetClassData() const { return &_class_data_; }


void ScheduleResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ScheduleResponse*>(&to_msg);
  auto& from = static_cast<const ScheduleResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:schedule.ScheduleResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.oddweek_.MergeFrom(from._impl_.oddweek_);
  _this->_impl_.evenweek_.MergeFrom(from._impl_.evenweek_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ScheduleResponse::CopyFrom(const ScheduleResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:schedule.ScheduleResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ScheduleResponse::IsInitialized() const {
  return true;
}

void ScheduleResponse::InternalSwap(ScheduleResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.oddweek_.InternalSwap(&other->_impl_.oddweek_);
  _impl_.evenweek_.InternalSwap(&other->_impl_.evenweek_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ScheduleResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_schedule_2eproto_getter, &descriptor_table_schedule_2eproto_once,
      file_level_metadata_schedule_2eproto[1]);
}

// ===================================================================

class Day::_Internal {
 public:
};

Day::Day(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:schedule.Day)
}
Day::Day(const Day& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Day* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.subjects_){from._impl_.subjects_}
    , decltype(_impl_.weekday_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.weekday_ = from._impl_.weekday_;
  // @@protoc_insertion_point(copy_constructor:schedule.Day)
}

inline void Day::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.subjects_){arena}
    , decltype(_impl_.weekday_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Day::~Day() {
  // @@protoc_insertion_point(destructor:schedule.Day)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Day::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.subjects_.~RepeatedPtrField();
}

void Day::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Day::Clear() {
// @@protoc_insertion_point(message_clear_start:schedule.Day)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.subjects_.Clear();
  _impl_.weekday_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Day::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 weekday = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.weekday_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .schedule.Subject subjects = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_subjects(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Day::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:schedule.Day)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 weekday = 1;
  if (this->_internal_weekday() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_weekday(), target);
  }

  // repeated .schedule.Subject subjects = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_subjects_size()); i < n; i++) {
    const auto& repfield = this->_internal_subjects(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:schedule.Day)
  return target;
}

size_t Day::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:schedule.Day)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .schedule.Subject subjects = 2;
  total_size += 1UL * this->_internal_subjects_size();
  for (const auto& msg : this->_impl_.subjects_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // int32 weekday = 1;
  if (this->_internal_weekday() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_weekday());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Day::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Day::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Day::GetClassData() const { return &_class_data_; }


void Day::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Day*>(&to_msg);
  auto& from = static_cast<const Day&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:schedule.Day)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.subjects_.MergeFrom(from._impl_.subjects_);
  if (from._internal_weekday() != 0) {
    _this->_internal_set_weekday(from._internal_weekday());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Day::CopyFrom(const Day& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:schedule.Day)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Day::IsInitialized() const {
  return true;
}

void Day::InternalSwap(Day* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.subjects_.InternalSwap(&other->_impl_.subjects_);
  swap(_impl_.weekday_, other->_impl_.weekday_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Day::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_schedule_2eproto_getter, &descriptor_table_schedule_2eproto_once,
      file_level_metadata_schedule_2eproto[2]);
}

// ===================================================================

class Subject::_Internal {
 public:
  static const ::schedule::Lecturer& lecturer(const Subject* msg);
  static const ::schedule::TimeRange& timerange(const Subject* msg);
};

const ::schedule::Lecturer&
Subject::_Internal::lecturer(const Subject* msg) {
  return *msg->_impl_.lecturer_;
}
const ::schedule::TimeRange&
Subject::_Internal::timerange(const Subject* msg) {
  return *msg->_impl_.timerange_;
}
Subject::Subject(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:schedule.Subject)
}
Subject::Subject(const Subject& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Subject* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.room_){}
    , decltype(_impl_.lecturer_){nullptr}
    , decltype(_impl_.timerange_){nullptr}
    , decltype(_impl_.type_){}
    , decltype(_impl_.number_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.room_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.room_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_room().empty()) {
    _this->_impl_.room_.Set(from._internal_room(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_lecturer()) {
    _this->_impl_.lecturer_ = new ::schedule::Lecturer(*from._impl_.lecturer_);
  }
  if (from._internal_has_timerange()) {
    _this->_impl_.timerange_ = new ::schedule::TimeRange(*from._impl_.timerange_);
  }
  ::memcpy(&_impl_.type_, &from._impl_.type_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.number_) -
    reinterpret_cast<char*>(&_impl_.type_)) + sizeof(_impl_.number_));
  // @@protoc_insertion_point(copy_constructor:schedule.Subject)
}

inline void Subject::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.room_){}
    , decltype(_impl_.lecturer_){nullptr}
    , decltype(_impl_.timerange_){nullptr}
    , decltype(_impl_.type_){0}
    , decltype(_impl_.number_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.room_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.room_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Subject::~Subject() {
  // @@protoc_insertion_point(destructor:schedule.Subject)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Subject::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  _impl_.room_.Destroy();
  if (this != internal_default_instance()) delete _impl_.lecturer_;
  if (this != internal_default_instance()) delete _impl_.timerange_;
}

void Subject::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Subject::Clear() {
// @@protoc_insertion_point(message_clear_start:schedule.Subject)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  _impl_.room_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.lecturer_ != nullptr) {
    delete _impl_.lecturer_;
  }
  _impl_.lecturer_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.timerange_ != nullptr) {
    delete _impl_.timerange_;
  }
  _impl_.timerange_ = nullptr;
  ::memset(&_impl_.type_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.number_) -
      reinterpret_cast<char*>(&_impl_.type_)) + sizeof(_impl_.number_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Subject::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "schedule.Subject.name"));
        } else
          goto handle_unusual;
        continue;
      // string room = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_room();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "schedule.Subject.room"));
        } else
          goto handle_unusual;
        continue;
      // .schedule.Subject.SubjectType type = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_type(static_cast<::schedule::Subject_SubjectType>(val));
        } else
          goto handle_unusual;
        continue;
      // .schedule.Lecturer lecturer = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_lecturer(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 number = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _impl_.number_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .schedule.TimeRange timeRange = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_timerange(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Subject::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:schedule.Subject)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "schedule.Subject.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // string room = 2;
  if (!this->_internal_room().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_room().data(), static_cast<int>(this->_internal_room().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "schedule.Subject.room");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_room(), target);
  }

  // .schedule.Subject.SubjectType type = 3;
  if (this->_internal_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_type(), target);
  }

  // .schedule.Lecturer lecturer = 4;
  if (this->_internal_has_lecturer()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::lecturer(this),
        _Internal::lecturer(this).GetCachedSize(), target, stream);
  }

  // int32 number = 5;
  if (this->_internal_number() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_number(), target);
  }

  // .schedule.TimeRange timeRange = 6;
  if (this->_internal_has_timerange()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::timerange(this),
        _Internal::timerange(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:schedule.Subject)
  return target;
}

size_t Subject::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:schedule.Subject)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // string room = 2;
  if (!this->_internal_room().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_room());
  }

  // .schedule.Lecturer lecturer = 4;
  if (this->_internal_has_lecturer()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.lecturer_);
  }

  // .schedule.TimeRange timeRange = 6;
  if (this->_internal_has_timerange()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.timerange_);
  }

  // .schedule.Subject.SubjectType type = 3;
  if (this->_internal_type() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
  }

  // int32 number = 5;
  if (this->_internal_number() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_number());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Subject::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Subject::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Subject::GetClassData() const { return &_class_data_; }


void Subject::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Subject*>(&to_msg);
  auto& from = static_cast<const Subject&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:schedule.Subject)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (!from._internal_room().empty()) {
    _this->_internal_set_room(from._internal_room());
  }
  if (from._internal_has_lecturer()) {
    _this->_internal_mutable_lecturer()->::schedule::Lecturer::MergeFrom(
        from._internal_lecturer());
  }
  if (from._internal_has_timerange()) {
    _this->_internal_mutable_timerange()->::schedule::TimeRange::MergeFrom(
        from._internal_timerange());
  }
  if (from._internal_type() != 0) {
    _this->_internal_set_type(from._internal_type());
  }
  if (from._internal_number() != 0) {
    _this->_internal_set_number(from._internal_number());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Subject::CopyFrom(const Subject& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:schedule.Subject)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Subject::IsInitialized() const {
  return true;
}

void Subject::InternalSwap(Subject* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.room_, lhs_arena,
      &other->_impl_.room_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Subject, _impl_.number_)
      + sizeof(Subject::_impl_.number_)
      - PROTOBUF_FIELD_OFFSET(Subject, _impl_.lecturer_)>(
          reinterpret_cast<char*>(&_impl_.lecturer_),
          reinterpret_cast<char*>(&other->_impl_.lecturer_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Subject::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_schedule_2eproto_getter, &descriptor_table_schedule_2eproto_once,
      file_level_metadata_schedule_2eproto[3]);
}

// ===================================================================

class Lecturer::_Internal {
 public:
};

Lecturer::Lecturer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:schedule.Lecturer)
}
Lecturer::Lecturer(const Lecturer& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Lecturer* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.firstname_){}
    , decltype(_impl_.lastname_){}
    , decltype(_impl_.middlename_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.firstname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.firstname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_firstname().empty()) {
    _this->_impl_.firstname_.Set(from._internal_firstname(), 
      _this->GetArenaForAllocation());
  }
  _impl_.lastname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.lastname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_lastname().empty()) {
    _this->_impl_.lastname_.Set(from._internal_lastname(), 
      _this->GetArenaForAllocation());
  }
  _impl_.middlename_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.middlename_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_middlename().empty()) {
    _this->_impl_.middlename_.Set(from._internal_middlename(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:schedule.Lecturer)
}

inline void Lecturer::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.firstname_){}
    , decltype(_impl_.lastname_){}
    , decltype(_impl_.middlename_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.firstname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.firstname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.lastname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.lastname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.middlename_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.middlename_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Lecturer::~Lecturer() {
  // @@protoc_insertion_point(destructor:schedule.Lecturer)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Lecturer::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.firstname_.Destroy();
  _impl_.lastname_.Destroy();
  _impl_.middlename_.Destroy();
}

void Lecturer::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Lecturer::Clear() {
// @@protoc_insertion_point(message_clear_start:schedule.Lecturer)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.firstname_.ClearToEmpty();
  _impl_.lastname_.ClearToEmpty();
  _impl_.middlename_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Lecturer::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string firstName = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_firstname();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "schedule.Lecturer.firstName"));
        } else
          goto handle_unusual;
        continue;
      // string lastName = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_lastname();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "schedule.Lecturer.lastName"));
        } else
          goto handle_unusual;
        continue;
      // string middleName = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_middlename();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "schedule.Lecturer.middleName"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Lecturer::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:schedule.Lecturer)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string firstName = 1;
  if (!this->_internal_firstname().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_firstname().data(), static_cast<int>(this->_internal_firstname().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "schedule.Lecturer.firstName");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_firstname(), target);
  }

  // string lastName = 2;
  if (!this->_internal_lastname().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_lastname().data(), static_cast<int>(this->_internal_lastname().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "schedule.Lecturer.lastName");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_lastname(), target);
  }

  // string middleName = 3;
  if (!this->_internal_middlename().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_middlename().data(), static_cast<int>(this->_internal_middlename().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "schedule.Lecturer.middleName");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_middlename(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:schedule.Lecturer)
  return target;
}

size_t Lecturer::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:schedule.Lecturer)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string firstName = 1;
  if (!this->_internal_firstname().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_firstname());
  }

  // string lastName = 2;
  if (!this->_internal_lastname().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_lastname());
  }

  // string middleName = 3;
  if (!this->_internal_middlename().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_middlename());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Lecturer::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Lecturer::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Lecturer::GetClassData() const { return &_class_data_; }


void Lecturer::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Lecturer*>(&to_msg);
  auto& from = static_cast<const Lecturer&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:schedule.Lecturer)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_firstname().empty()) {
    _this->_internal_set_firstname(from._internal_firstname());
  }
  if (!from._internal_lastname().empty()) {
    _this->_internal_set_lastname(from._internal_lastname());
  }
  if (!from._internal_middlename().empty()) {
    _this->_internal_set_middlename(from._internal_middlename());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Lecturer::CopyFrom(const Lecturer& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:schedule.Lecturer)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Lecturer::IsInitialized() const {
  return true;
}

void Lecturer::InternalSwap(Lecturer* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.firstname_, lhs_arena,
      &other->_impl_.firstname_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.lastname_, lhs_arena,
      &other->_impl_.lastname_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.middlename_, lhs_arena,
      &other->_impl_.middlename_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata Lecturer::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_schedule_2eproto_getter, &descriptor_table_schedule_2eproto_once,
      file_level_metadata_schedule_2eproto[4]);
}

// ===================================================================

class TimeRange::_Internal {
 public:
  static const ::schedule::TimeOfDay& start(const TimeRange* msg);
  static const ::schedule::TimeOfDay& end(const TimeRange* msg);
};

const ::schedule::TimeOfDay&
TimeRange::_Internal::start(const TimeRange* msg) {
  return *msg->_impl_.start_;
}
const ::schedule::TimeOfDay&
TimeRange::_Internal::end(const TimeRange* msg) {
  return *msg->_impl_.end_;
}
TimeRange::TimeRange(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:schedule.TimeRange)
}
TimeRange::TimeRange(const TimeRange& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TimeRange* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.start_){nullptr}
    , decltype(_impl_.end_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_start()) {
    _this->_impl_.start_ = new ::schedule::TimeOfDay(*from._impl_.start_);
  }
  if (from._internal_has_end()) {
    _this->_impl_.end_ = new ::schedule::TimeOfDay(*from._impl_.end_);
  }
  // @@protoc_insertion_point(copy_constructor:schedule.TimeRange)
}

inline void TimeRange::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.start_){nullptr}
    , decltype(_impl_.end_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

TimeRange::~TimeRange() {
  // @@protoc_insertion_point(destructor:schedule.TimeRange)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TimeRange::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.start_;
  if (this != internal_default_instance()) delete _impl_.end_;
}

void TimeRange::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TimeRange::Clear() {
// @@protoc_insertion_point(message_clear_start:schedule.TimeRange)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.start_ != nullptr) {
    delete _impl_.start_;
  }
  _impl_.start_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.end_ != nullptr) {
    delete _impl_.end_;
  }
  _impl_.end_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TimeRange::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .schedule.TimeOfDay start = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_start(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .schedule.TimeOfDay end = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_end(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TimeRange::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:schedule.TimeRange)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .schedule.TimeOfDay start = 1;
  if (this->_internal_has_start()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::start(this),
        _Internal::start(this).GetCachedSize(), target, stream);
  }

  // .schedule.TimeOfDay end = 2;
  if (this->_internal_has_end()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::end(this),
        _Internal::end(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:schedule.TimeRange)
  return target;
}

size_t TimeRange::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:schedule.TimeRange)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .schedule.TimeOfDay start = 1;
  if (this->_internal_has_start()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.start_);
  }

  // .schedule.TimeOfDay end = 2;
  if (this->_internal_has_end()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.end_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TimeRange::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TimeRange::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TimeRange::GetClassData() const { return &_class_data_; }


void TimeRange::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TimeRange*>(&to_msg);
  auto& from = static_cast<const TimeRange&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:schedule.TimeRange)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_start()) {
    _this->_internal_mutable_start()->::schedule::TimeOfDay::MergeFrom(
        from._internal_start());
  }
  if (from._internal_has_end()) {
    _this->_internal_mutable_end()->::schedule::TimeOfDay::MergeFrom(
        from._internal_end());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TimeRange::CopyFrom(const TimeRange& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:schedule.TimeRange)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TimeRange::IsInitialized() const {
  return true;
}

void TimeRange::InternalSwap(TimeRange* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TimeRange, _impl_.end_)
      + sizeof(TimeRange::_impl_.end_)
      - PROTOBUF_FIELD_OFFSET(TimeRange, _impl_.start_)>(
          reinterpret_cast<char*>(&_impl_.start_),
          reinterpret_cast<char*>(&other->_impl_.start_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TimeRange::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_schedule_2eproto_getter, &descriptor_table_schedule_2eproto_once,
      file_level_metadata_schedule_2eproto[5]);
}

// ===================================================================

class TimeOfDay::_Internal {
 public:
};

TimeOfDay::TimeOfDay(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:schedule.TimeOfDay)
}
TimeOfDay::TimeOfDay(const TimeOfDay& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TimeOfDay* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.hour_){}
    , decltype(_impl_.minute_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.hour_, &from._impl_.hour_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.minute_) -
    reinterpret_cast<char*>(&_impl_.hour_)) + sizeof(_impl_.minute_));
  // @@protoc_insertion_point(copy_constructor:schedule.TimeOfDay)
}

inline void TimeOfDay::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.hour_){0}
    , decltype(_impl_.minute_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

TimeOfDay::~TimeOfDay() {
  // @@protoc_insertion_point(destructor:schedule.TimeOfDay)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TimeOfDay::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void TimeOfDay::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TimeOfDay::Clear() {
// @@protoc_insertion_point(message_clear_start:schedule.TimeOfDay)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.hour_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.minute_) -
      reinterpret_cast<char*>(&_impl_.hour_)) + sizeof(_impl_.minute_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TimeOfDay::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 hour = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.hour_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 minute = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.minute_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TimeOfDay::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:schedule.TimeOfDay)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 hour = 1;
  if (this->_internal_hour() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_hour(), target);
  }

  // int32 minute = 2;
  if (this->_internal_minute() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_minute(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:schedule.TimeOfDay)
  return target;
}

size_t TimeOfDay::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:schedule.TimeOfDay)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int32 hour = 1;
  if (this->_internal_hour() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_hour());
  }

  // int32 minute = 2;
  if (this->_internal_minute() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_minute());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TimeOfDay::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TimeOfDay::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TimeOfDay::GetClassData() const { return &_class_data_; }


void TimeOfDay::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TimeOfDay*>(&to_msg);
  auto& from = static_cast<const TimeOfDay&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:schedule.TimeOfDay)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_hour() != 0) {
    _this->_internal_set_hour(from._internal_hour());
  }
  if (from._internal_minute() != 0) {
    _this->_internal_set_minute(from._internal_minute());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TimeOfDay::CopyFrom(const TimeOfDay& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:schedule.TimeOfDay)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TimeOfDay::IsInitialized() const {
  return true;
}

void TimeOfDay::InternalSwap(TimeOfDay* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TimeOfDay, _impl_.minute_)
      + sizeof(TimeOfDay::_impl_.minute_)
      - PROTOBUF_FIELD_OFFSET(TimeOfDay, _impl_.hour_)>(
          reinterpret_cast<char*>(&_impl_.hour_),
          reinterpret_cast<char*>(&other->_impl_.hour_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TimeOfDay::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_schedule_2eproto_getter, &descriptor_table_schedule_2eproto_once,
      file_level_metadata_schedule_2eproto[6]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace schedule
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::schedule::ScheduleRequest*
Arena::CreateMaybeMessage< ::schedule::ScheduleRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::schedule::ScheduleRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::schedule::ScheduleResponse*
Arena::CreateMaybeMessage< ::schedule::ScheduleResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::schedule::ScheduleResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::schedule::Day*
Arena::CreateMaybeMessage< ::schedule::Day >(Arena* arena) {
  return Arena::CreateMessageInternal< ::schedule::Day >(arena);
}
template<> PROTOBUF_NOINLINE ::schedule::Subject*
Arena::CreateMaybeMessage< ::schedule::Subject >(Arena* arena) {
  return Arena::CreateMessageInternal< ::schedule::Subject >(arena);
}
template<> PROTOBUF_NOINLINE ::schedule::Lecturer*
Arena::CreateMaybeMessage< ::schedule::Lecturer >(Arena* arena) {
  return Arena::CreateMessageInternal< ::schedule::Lecturer >(arena);
}
template<> PROTOBUF_NOINLINE ::schedule::TimeRange*
Arena::CreateMaybeMessage< ::schedule::TimeRange >(Arena* arena) {
  return Arena::CreateMessageInternal< ::schedule::TimeRange >(arena);
}
template<> PROTOBUF_NOINLINE ::schedule::TimeOfDay*
Arena::CreateMaybeMessage< ::schedule::TimeOfDay >(Arena* arena) {
  return Arena::CreateMessageInternal< ::schedule::TimeOfDay >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
